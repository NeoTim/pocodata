namespace Unosquare.PocoData
{
    using System;
    using System.Reflection;
    using System.Runtime.CompilerServices;

    /// <summary>
    /// Represents aggregated information about the data related attributes applied to properties.
    /// </summary>
    public sealed class ColumnMetadata
    {
        private readonly IPropertyProxy Proxy;

        /// <summary>
        /// Initializes a new instance of the <see cref="ColumnMetadata"/> class.
        /// </summary>
        /// <param name="property">The property.</param>
        /// <param name="columnName">Name of the column.</param>
        /// <param name="length">The length.</param>
        /// <param name="isNullable">if set to <c>true</c> [is nullable].</param>
        /// <param name="isKey">if set to <c>true</c> [is key].</param>
        /// <param name="isGenerated">if set to <c>true</c> [is generated].</param>
        internal ColumnMetadata(PropertyInfo property, string columnName, int length, bool isNullable, bool isKey, bool isGenerated)
        {
            Property = property;
            StringLength = length;
            ColumnName = columnName;
            IsKeyColumn = isKey;
            IsKeyGenerated = isKey && isGenerated;
            IsNullable = isNullable;
            NativeType = Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType;

            if (NativeType.IsEnum)
                NativeType = NativeType.GetEnumUnderlyingType();

            Proxy = CreatePropertyProxy(property);
        }

        /// <summary>
        /// Gets the property.
        /// </summary>
        public PropertyInfo Property { get; }

        /// <summary>
        /// Gets the name of the property.
        /// </summary>
        public string PropertyName => Property.Name;

        /// <summary>
        /// Gets the CLR underlying type of the property.
        /// This for nullables it returns the underlying types.
        /// It does so for enums as well.
        /// </summary>
        public Type NativeType { get; }

        /// <summary>
        /// Gets the string length.
        /// </summary>
        public int StringLength { get; }

        /// <summary>
        /// Gets a value indicating whether the property represents a key column.
        /// </summary>
        public bool IsKeyColumn { get; }

        /// <summary>
        /// Gets a value indicating whether the property represents a key which has its value
        /// generated by the database such as identity columns or autonumbers.
        /// </summary>
        public bool IsKeyGenerated { get; }

        /// <summary>
        /// Gets a value indicating whether the column accepts nulls.
        /// </summary>
        public bool IsNullable { get; }

        /// <summary>
        /// Gets the name of the column the property maps to.
        /// </summary>
        public string ColumnName { get; }

        /// <summary>
        /// Gets the qualified name of the column.
        /// </summary>
        public string QualifiedName => $"[{ColumnName}]";

        /// <summary>
        /// Gets the name of the parameter to be used. This is simply the property name preceeded by an at symbol.
        /// </summary>
        public string ParameterName => $"@{PropertyName}";

        /// <summary>
        /// Gets the default value of the property type.
        /// </summary>
        /// <returns>The default value</returns>
        public object GetDefault() => GetDefault(Property.PropertyType);

        /// <summary>
        /// Gets the value for the given property via a stored delegate.
        /// This is a high performance way of retrieving property values dynamically.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <returns></returns>
        public object GetValue(object instance) => Proxy.GetValue(instance);

        /// <summary>
        /// Sets the value for the given property via a stored delegate.
        /// This is a high performance way of setting property values dynamically.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="value">The value.</param>
        public void SetValue(object instance, object value) => Proxy.SetValue(instance, value);

        /// <summary>
        /// Gets the default value for a type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns></returns>
        private static object GetDefault(Type type) =>
            type.IsValueType ? Activator.CreateInstance(type) : null;

        /// <summary>
        /// Creates a property proxy that stores getter and setter delegates.
        /// </summary>
        /// <param name="propertyInfo">The property information.</param>
        /// <returns></returns>
        private static IPropertyProxy CreatePropertyProxy(PropertyInfo propertyInfo)
        {
            var genericType = typeof(PropertyProxy<,>)
                .MakeGenericType(propertyInfo.DeclaringType, propertyInfo.PropertyType);
            return Activator.CreateInstance(genericType, propertyInfo) as IPropertyProxy;
        }

        /// <summary>
        /// Represents a generic interface to store getters and setters.
        /// </summary>
        private interface IPropertyProxy
        {
            /// <summary>
            /// Gets the property value.
            /// </summary>
            /// <param name="instance">The instance.</param>
            /// <returns></returns>
            object GetValue(object instance);

            /// <summary>
            /// Sets the property value.
            /// </summary>
            /// <param name="instance">The instance.</param>
            /// <param name="value">The value.</param>
            void SetValue(object instance, object value);
        }

        /// <summary>
        /// Represents a generic class to store getters and setters.
        /// </summary>
        /// <typeparam name="TClass">The type of the class.</typeparam>
        /// <typeparam name="TProperty">The type of the property.</typeparam>
        /// <seealso cref="Unosquare.PocoData.ColumnMetadata.IPropertyProxy" />
        internal sealed class PropertyProxy<TClass, TProperty> : IPropertyProxy
            where TClass : class
        {
            private readonly Func<TClass, TProperty> Getter;
            private readonly Action<TClass, TProperty> Setter;

            /// <summary>
            /// Initializes a new instance of the <see cref="PropertyProxy{TClass, TProperty}"/> class.
            /// </summary>
            /// <param name="property">The property.</param>
            public PropertyProxy(PropertyInfo property)
            {
                var getterInfo = property.GetGetMethod(false);
                if (getterInfo != null)
                    Getter = (Func<TClass, TProperty>)Delegate.CreateDelegate(typeof(Func<TClass, TProperty>), getterInfo);

                var setterInfo = property.GetSetMethod(false);
                if (setterInfo != null)
                    Setter = (Action<TClass, TProperty>)Delegate.CreateDelegate(typeof(Action<TClass, TProperty>), setterInfo);
            }

            /// <inheritdoc />
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            object IPropertyProxy.GetValue(object instance) =>
                Getter(instance as TClass);

            /// <inheritdoc />
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            void IPropertyProxy.SetValue(object instance, object value) =>
                Setter(instance as TClass, (TProperty)value);
        }
    }
}
