namespace Unosquare.PocoData
{
    using System;
    using System.Reflection;

    /// <summary>
    /// Represents aggregated information about the data related attributes applied to properties.
    /// </summary>
    public sealed class ColumnMetadata
    {
        private readonly IPropertyProxy Proxy;

        /// <summary>
        /// Initializes a new instance of the <see cref="ColumnMetadata"/> class.
        /// </summary>
        /// <param name="property">The property.</param>
        /// <param name="columnName">Name of the column.</param>
        /// <param name="length">The length.</param>
        /// <param name="isNullable">if set to <c>true</c> [is nullable].</param>
        /// <param name="isKey">if set to <c>true</c> [is key].</param>
        /// <param name="isGenerated">if set to <c>true</c> [is generated].</param>
        internal ColumnMetadata(PropertyInfo property, string columnName, int length, bool isNullable, bool isKey, bool isGenerated)
        {
            Property = property;
            StringLength = length;
            ColumnName = columnName;
            IsKeyColumn = isKey;
            IsKeyGenerated = isKey && isGenerated;
            IsNullable = isNullable;
            NativeType = Nullable.GetUnderlyingType(property.PropertyType) ?? property.PropertyType;

            if (NativeType.IsEnum)
                NativeType = NativeType.GetEnumUnderlyingType();

            Proxy = CreatePropertyProxy(property);
        }

        /// <summary>
        /// Gets the property.
        /// </summary>
        public PropertyInfo Property { get; }

        /// <summary>
        /// Gets the name of the property.
        /// </summary>
        public string PropertyName => Property.Name;

        /// <summary>
        /// Gets the CLR underlying type of the property.
        /// This for nullables it returns the underlying types.
        /// It does so for enums as well.
        /// </summary>
        public Type NativeType { get; }

        /// <summary>
        /// Gets the string length.
        /// </summary>
        public int StringLength { get; internal set; }

        /// <summary>
        /// Gets a value indicating whether the property represents a key column.
        /// </summary>
        public bool IsKeyColumn { get; internal set; }

        /// <summary>
        /// Gets a value indicating whether the property represents a key which has its value
        /// generated by the database such as identity columns or autonumbers.
        /// </summary>
        public bool IsKeyGenerated { get; internal set; }

        /// <summary>
        /// Gets a value indicating whether the column accepts nulls.
        /// </summary>
        public bool IsNullable { get; internal set; }

        /// <summary>
        /// Gets the name of the column the property maps to.
        /// </summary>
        public string ColumnName { get; internal set; }

        /// <summary>
        /// Gets the qualified name of the column.
        /// </summary>
        public string QualifiedName => $"[{ColumnName}]";

        /// <summary>
        /// Gets the name of the parameter to be used. This is simply the property name preceeded by an at symbol.
        /// </summary>
        public string ParameterName => $"@{PropertyName}";

        /// <summary>
        /// Gets the default value of the property type.
        /// </summary>
        /// <returns>The default value</returns>
        public object GetDefault() => GetDefault(Property.PropertyType);

        /// <summary>
        /// Gets the value for the given property via a stored delegate.
        /// This is a high performance way of retrieving property values dynamically.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <returns>The property value.</returns>
        public object GetValue(object instance) => Proxy.GetValue(instance);

        /// <summary>
        /// Sets the value for the given property via a stored delegate.
        /// This is a high performance way of setting property values dynamically.
        /// </summary>
        /// <param name="instance">The instance.</param>
        /// <param name="value">The value.</param>
        public void SetValue(object instance, object value) => Proxy.SetValue(instance, value);

        /// <summary>
        /// Gets the default value for a type.
        /// </summary>
        /// <param name="type">The type.</param>
        /// <returns>The default value.</returns>
        private static object GetDefault(Type type) =>
            type.IsValueType ? Activator.CreateInstance(type) : null;

        /// <summary>
        /// Creates a property proxy that stores getter and setter delegates.
        /// </summary>
        /// <param name="propertyInfo">The property information.</param>
        /// <returns>The property proxy.</returns>
        private static IPropertyProxy CreatePropertyProxy(PropertyInfo propertyInfo)
        {
            var genericType = typeof(PropertyProxy<,>)
                .MakeGenericType(propertyInfo.DeclaringType, propertyInfo.PropertyType);
            return Activator.CreateInstance(genericType, propertyInfo) as IPropertyProxy;
        }
    }
}
